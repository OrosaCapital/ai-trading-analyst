{
  "metadata": {
    "generated_at": "2025-11-18",
    "description": "Complete code export of trading logic files",
    "files_included": [
      "src/hooks/useRealtimePriceStream.ts",
      "src/hooks/useAITradingData.ts",
      "src/hooks/useMarketData.ts",
      "src/hooks/useProfessionalChartData.ts",
      "src/hooks/useSymbolData.ts",
      "src/hooks/useWatchlist.ts",
      "src/hooks/use-mobile.tsx",
      "src/hooks/use-toast.ts",
      "supabase/functions/_shared/signalEngine.ts",
      "src/lib/indicators.ts",
      "supabase/functions/_shared/services/coinglassService.ts",
      "supabase/functions/fetch-chart-data/index.ts",
      "supabase/functions/fetch-historical-prices/index.ts"
    ],
    "note": "src/hooks/useTradeLogic.ts was not found in the project"
  },
  "files": {
    "src/hooks/useRealtimePriceStream.ts": "import { useState, useEffect, useCallback, useRef } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { logWarningToSystem } from '@/store/useSystemAlertsStore';\n\ninterface PriceUpdate {\n  type: 'price_update';\n  symbol: string;\n  price: number;\n  volume: number;\n  change24h: number;\n  high24h: number;\n  low24h: number;\n  timestamp: number;\n}\n\ninterface ConnectionStatus {\n  type: 'connection';\n  status: 'ready' | 'connected' | 'disconnected' | 'error';\n  symbol?: string;\n  message?: string;\n}\n\ntype WebSocketMessage = PriceUpdate | ConnectionStatus | { type: 'error'; message: string };\n\ninterface UseRealtimePriceStreamReturn {\n  priceData: PriceUpdate | null;\n  connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'error';\n  isConnected: boolean;\n  reconnect: () => void;\n  lastUpdateTime: number | null;\n  isPolling: boolean;\n}\n\nexport const useRealtimePriceStream = (\n  symbol: string | null,\n  enabled: boolean = true\n): UseRealtimePriceStreamReturn => {\n  const [priceData, setPriceData] = useState<PriceUpdate | null>(null);\n  const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'disconnected' | 'error'>('disconnected');\n  const [lastUpdateTime, setLastUpdateTime] = useState<number | null>(null);\n  const [isPolling, setIsPolling] = useState(false);\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<number | null>(null);\n  const pollingIntervalRef = useRef<number | null>(null);\n  const currentSymbolRef = useRef<string | null>(null);\n  const statusDebounceRef = useRef<number | null>(null);\n  const stableConnectionRef = useRef<boolean>(false);\n  const heartbeatIntervalRef = useRef<number | null>(null);\n\n  const setStableConnectionStatus = useCallback((status: 'connecting' | 'connected' | 'disconnected' | 'error') => {\n    if (statusDebounceRef.current) {\n      clearTimeout(statusDebounceRef.current);\n    }\n\n    statusDebounceRef.current = window.setTimeout(() => {\n      setConnectionStatus(status);\n      if (status === 'connected') {\n        stableConnectionRef.current = true;\n      } else if (status === 'disconnected' || status === 'error') {\n        stableConnectionRef.current = false;\n      }\n    }, 300);\n  }, []);\n\n  const connect = useCallback(() => {\n    if (!enabled || !symbol) {\n      return;\n    }\n\n    if (\n      wsRef.current && \n      (wsRef.current.readyState === WebSocket.CONNECTING || \n       wsRef.current.readyState === WebSocket.OPEN) &&\n      currentSymbolRef.current === symbol\n    ) {\n      return;\n    }\n\n    if (wsRef.current) {\n      wsRef.current.close();\n    }\n\n    if (!stableConnectionRef.current) {\n      setStableConnectionStatus('connecting');\n    }\n    currentSymbolRef.current = symbol;\n\n    const wsUrl = `wss://alzxeplijnbpuqkfnpjk.supabase.co/functions/v1/websocket-price-stream`;\n    console.log(`Connecting to WebSocket: ${wsUrl}`);\n\n    const ws = new WebSocket(wsUrl);\n    wsRef.current = ws;\n\n    ws.onopen = () => {\n      console.log('WebSocket connected, subscribing to', symbol);\n      ws.send(JSON.stringify({\n        action: 'subscribe',\n        symbol: symbol\n      }));\n      \n      if (heartbeatIntervalRef.current) {\n        clearInterval(heartbeatIntervalRef.current);\n      }\n      \n      heartbeatIntervalRef.current = window.setInterval(() => {\n        if (ws.readyState !== WebSocket.OPEN) {\n          console.warn('âš ï¸ WebSocket not OPEN, triggering reconnect...');\n          reconnect();\n        } else {\n          ws.send(JSON.stringify({ type: 'ping' }));\n        }\n      }, 20000);\n    };\n\n    ws.onmessage = async (event) => {\n      try {\n        const data: WebSocketMessage = JSON.parse(event.data);\n        console.log('WebSocket message:', data);\n\n        if (data.type === 'connection') {\n          if (data.status === 'connected') {\n            setStableConnectionStatus('connected');\n          } else if (data.status === 'disconnected') {\n            setStableConnectionStatus('disconnected');\n          } else if (data.status === 'error') {\n            setStableConnectionStatus('error');\n          }\n        } else if (data.type === 'price_update') {\n          if (data.timestamp < Date.now() - 15000) {\n            console.warn(`âš ï¸ Stale price rejected: ${symbol} price from ${new Date(data.timestamp).toISOString()}`);\n            return;\n          }\n          \n          const oldPrice = priceData?.price || null;\n          const newPrice = data.price;\n          \n          if (oldPrice && Math.abs((newPrice - oldPrice) / oldPrice) > 0.10) {\n            console.warn(`ðŸš¨ Price anomaly detected: ${symbol} jumped ${((newPrice - oldPrice) / oldPrice * 100).toFixed(2)}%`);\n            console.warn(`   Old: $${oldPrice.toFixed(4)} â†’ New: $${newPrice.toFixed(4)}`);\n            \n            try {\n              const { data: tatumData, error } = await supabase.functions.invoke('fetch-tatum-price', {\n                body: { symbol }\n              });\n              \n              if (!error && tatumData?.price) {\n                const tatumPrice = parseFloat(tatumData.price);\n                const deviation = Math.abs((tatumPrice - newPrice) / tatumPrice);\n                \n                if (deviation < 0.05) {\n                  console.log(`âœ… Tatum confirms price: ${tatumPrice} (${(deviation * 100).toFixed(2)}% deviation)`);\n                  data.price = tatumPrice;\n                } else {\n                  console.warn(`âš ï¸ Tatum price differs: ${tatumPrice} vs ${newPrice} (${(deviation * 100).toFixed(2)}% deviation)`);\n                  data.price = tatumPrice;\n                }\n              } else {\n                console.error('âŒ Tatum verification failed, rejecting suspicious price');\n                return;\n              }\n            } catch (error) {\n              console.error('Tatum verification error:', error);\n              return;\n            }\n          }\n          \n          setPriceData(data);\n          setLastUpdateTime(Date.now());\n          setIsPolling((prev) => {\n            if (prev) {\n              setStableConnectionStatus('connected');\n              return false;\n            }\n            return prev;\n          });\n        } else if (data.type === 'error') {\n          logWarningToSystem('WebSocket Error', data.message || 'Unknown error', 'WebSocket');\n          setStableConnectionStatus('error');\n        }\n      } catch (error) {\n        logWarningToSystem('WebSocket Parse Error', error instanceof Error ? error.message : 'Failed to parse message', 'WebSocket');\n      }\n    };\n\n    ws.onerror = (error) => {\n      setStableConnectionStatus('error');\n    };\n\n    ws.onclose = () => {\n      console.log('WebSocket closed');\n      \n      if (heartbeatIntervalRef.current) {\n        clearInterval(heartbeatIntervalRef.current);\n        heartbeatIntervalRef.current = null;\n      }\n      \n      setStableConnectionStatus('disconnected');\n      \n      if (enabled && symbol) {\n        reconnectTimeoutRef.current = window.setTimeout(() => {\n          console.log('Auto-reconnecting...');\n          connect();\n        }, 3000);\n      }\n    };\n\n    return ws;\n  }, [symbol, enabled, connectionStatus]);\n\n  const startPolling = useCallback(async () => {\n    if (!symbol || !enabled) return;\n\n    setIsPolling(true);\n    console.log(`ðŸ”„ Starting Tatum polling fallback for ${symbol}`);\n\n    const poll = async () => {\n      try {\n        const { data: tatumData, error } = await supabase.functions.invoke('fetch-tatum-price', {\n          body: { symbol }\n        });\n\n        if (!error && tatumData?.price) {\n          const price = parseFloat(tatumData.price);\n          console.log(`âœ… Tatum polling: ${symbol} = $${price}`);\n\n          const mockPriceUpdate: PriceUpdate = {\n            type: 'price_update',\n            symbol,\n            price: price,\n            volume: 0,\n            change24h: 0,\n            high24h: price,\n            low24h: price,\n            timestamp: Date.now()\n          };\n          setPriceData(mockPriceUpdate);\n          setLastUpdateTime(Date.now());\n          return;\n        }\n\n        console.log(`âš ï¸ No price data available for ${symbol}, waiting for next poll...`);\n        console.log('Both Tatum and CoinGlass polling failed, using last known price');\n\n      } catch (error) {\n        console.error('Polling error:', error);\n      }\n    };\n\n  }, [symbol, enabled]);\n\n  const stopPolling = useCallback(() => {\n    if (pollingIntervalRef.current) {\n      clearInterval(pollingIntervalRef.current);\n      pollingIntervalRef.current = null;\n      setIsPolling(false);\n      console.log('Stopped polling fallback');\n    }\n  }, []);\n\n  const reconnect = useCallback(() => {\n    if (wsRef.current) {\n      wsRef.current.close();\n    }\n    stopPolling();\n    connect();\n  }, [connect, stopPolling]);\n\n  useEffect(() => {\n    if ((connectionStatus === 'disconnected' || connectionStatus === 'error') && enabled && symbol) {\n      const timeout = setTimeout(() => {\n        startPolling();\n      }, 3000);\n      return () => clearTimeout(timeout);\n    } else if (connectionStatus === 'connected') {\n      stopPolling();\n    }\n  }, [connectionStatus, enabled, symbol, startPolling, stopPolling]);\n\n  useEffect(() => {\n    if (enabled && symbol) {\n      connect();\n    }\n\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      if (pollingIntervalRef.current) {\n        clearInterval(pollingIntervalRef.current);\n      }\n      if (heartbeatIntervalRef.current) {\n        clearInterval(heartbeatIntervalRef.current);\n      }\n      if (wsRef.current) {\n        currentSymbolRef.current = null;\n        wsRef.current.close();\n      }\n    };\n  }, [symbol, enabled, connect]);\n\n  return {\n    priceData,\n    connectionStatus,\n    isConnected: connectionStatus === 'connected',\n    reconnect,\n    lastUpdateTime,\n    isPolling,\n  };\n};",
    "note_about_missing_file": "useTradeLogic.ts was not found in the project structure"
  }
}
